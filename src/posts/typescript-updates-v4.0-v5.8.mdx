---
title: TypeScript v4.0からv5.8までの更新内容
date: "2025-03-07 00:00:00"
description: TypeScript v4.0から最新のv5.8までの主要な更新内容を日本語でまとめた記事
tags: [TypeScript, プログラミング]
featuredImage: 
---


このドキュメントは、Devin AIによって生成されたTypeScript v4.0から最新のv5.8までの主要な更新内容を日本語でまとめた記事です。各バージョンで追加された重要な機能や変更点を、公式ドキュメントを基に解説しています。バグ修正や軽微な変更は除外し、主要な機能に焦点を当てています。

## 出典元

この記事は以下の公式TypeScriptリリースノートを参照して作成されています：

- [TypeScript 4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)
- [TypeScript 4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)
- [TypeScript 4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)
- [TypeScript 4.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html)
- [TypeScript 4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)
- [TypeScript 4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html)
- [TypeScript 4.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html)
- [TypeScript 4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)
- [TypeScript 4.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html)
- [TypeScript 4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html)
- [TypeScript 5.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html)
- [TypeScript 5.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html)
- [TypeScript 5.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html)
- [TypeScript 5.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html)
- [TypeScript 5.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html)
- [TypeScript 5.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html)
- [TypeScript 5.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html)
- [TypeScript 5.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html)
- [TypeScript 5.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html)

## 目次

- [TypeScript 4.0](#typescript-40)
- [TypeScript 4.1](#typescript-41)
- [TypeScript 4.2](#typescript-42)
- [TypeScript 4.3](#typescript-43)
- [TypeScript 4.4](#typescript-44)
- [TypeScript 4.5](#typescript-45)
- [TypeScript 4.6](#typescript-46)
- [TypeScript 4.7](#typescript-47)
- [TypeScript 4.8](#typescript-48)
- [TypeScript 4.9](#typescript-49)
- [TypeScript 5.0](#typescript-50)
- [TypeScript 5.1](#typescript-51)
- [TypeScript 5.2](#typescript-52)
- [TypeScript 5.3](#typescript-53)
- [TypeScript 5.4](#typescript-54)
- [TypeScript 5.5](#typescript-55)
- [TypeScript 5.6](#typescript-56)
- [TypeScript 5.7](#typescript-57)
- [TypeScript 5.8](#typescript-58)

## TypeScript 4.0

### 主な変更点

- **可変長タプル型 (Variadic Tuple Types)**: タプル型のスプレッド構文がジェネリックになり、高度な操作が可能になりました。タプル内の残余要素（rest elements）が任意の位置に配置可能になり、関数のオーバーロードを大量に書かなくても型安全な関数を定義できるようになりました。

- **ラベル付きタプル要素 (Labeled Tuple Elements)**: タプル型の各要素にラベルを付けられるようになり、可読性が向上しました。関数のパラメータリストとタプル型の間の関係がより明確になり、オプショナルな要素や残余要素の構文も関数パラメータと同様になりました。

- **コンストラクタからのクラスプロパティ型推論 (Class Property Inference from Constructors)**: noImplicitAnyが有効な場合、コンストラクタでの代入からクラスプロパティの型を推論するようになりました。すべてのパスで初期化されない場合は、型に`undefined`が含まれます。

- **短絡代入演算子 (Short-Circuiting Assignment Operators)**: 論理AND（&&=）、論理OR（||=）、Nullish合体演算子（??=）の代入バージョンをサポートし、条件付きで代入を行う場合に簡潔に記述可能になりました。

- **catchの変数に対するunknown型の指定 (unknown on catch Clause Bindings)**: catch句の変数の型をanyの代わりにunknownとして指定可能になり、より型安全なエラーハンドリングが可能になりました。

- **カスタムJSXファクトリ (Custom JSX Factories)**: jsxFragmentFactoryオプションを追加し、フラグメントファクトリをカスタマイズ可能になりました。/** @jsxFrag */プラグマコメントでファイルごとに設定可能です。

### 新しい構文

```typescript
// 可変長タプル型の例
type Arr = readonly any[];
function concat<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U] {
  return [...arr1, ...arr2];
}

// ラベル付きタプル要素の例
type Range = [start: number, end: number];
type Foo = [first: number, second?: string, ...rest: any[]];

// 短絡代入演算子の例
// a &&= b は a = a && b と同じ
// a ||= b は a = a || b と同じ
// a ??= b は a = a ?? b と同じ
let x = 0;
x ||= 1; // x が falsy なら 1 を代入

// catchの変数に対するunknown型の指定
try {
  // 何かの処理
} catch (e: unknown) {
  // e は unknown 型なので、使用前に型チェックが必要
  if (e instanceof Error) {
    console.log(e.message);
  }
}

// カスタムJSXファクトリの例
/** @jsx h */
/** @jsxFrag Fragment */
import { h, Fragment } from 'preact';

const element = (
  <>
    <div>Hello</div>
  </>
);
```

## TypeScript 4.1

### 主な変更点

- **テンプレートリテラル型 (Template Literal Types)**: 文字列リテラル型を組み合わせて新しい文字列リテラル型を作成できる機能が追加されました。JavaScriptのテンプレートリテラル構文と同様の構文を型の位置で使用でき、ユニオン型と組み合わせると、可能なすべての文字列の組み合わせを生成できます。型の推論にも使用可能で、文字列から情報を抽出して型安全に処理できます。また、文字列の変換用ユーティリティ型（Uppercase、Lowercase、Capitalize、Uncapitalize）も追加されました。

- **マップ型でのキーのリマッピング (Key Remapping in Mapped Types)**: マップ型内でキーを変換するための新しい`as`句が導入されました。既存のプロパティ名から新しいプロパティ名を生成可能になり、テンプレートリテラル型と組み合わせることで、命名パターンの変換が容易になりました。`never`を生成することでプロパティをフィルタリングすることも可能です。

- **再帰的な条件付き型 (Recursive Conditional Types)**: 条件付き型が自身を参照できるようになり、再帰的な型エイリアスが容易になりました。深くネストされた配列や`Promise`チェーンなどの複雑な型を表現可能になり、型システムの表現力が大幅に向上しました。

- **チェックされたインデックスアクセス (Checked Indexed Accesses)**: 新しいコンパイラフラグ`--noUncheckedIndexedAccess`が導入され、プロパティアクセスやインデックスアクセスが潜在的に`undefined`になる可能性を考慮するようになりました。より厳格な型チェックにより、実行時エラーを防止できます。

- **baseUrlなしでのpathsの使用 (paths without baseUrl)**: `paths`オプションが`baseUrl`なしで使用可能になり、パスマッピングをより柔軟に設定できるようになりました。

- **React 17 JSXファクトリ (React 17 JSX Factories)**: React 17の新しいJSX変換をサポートする新しいjsxコンパイラオプションが追加されました。`react-jsx`と`react-jsxdev`の2つの新しいオプションが利用可能になりました。

### 新しい構文

```typescript
// テンプレートリテラル型の例
type World = "world";
type Greeting = `hello ${World}`; // "hello world"型

// ユニオン型との組み合わせ
type Color = "red" | "blue";
type Quantity = "one" | "two";
type SeussFish = `${Quantity | Color} fish`; // "one fish" | "two fish" | "red fish" | "blue fish"型

// 文字列変換ユーティリティ型
type Greeting = "Hello, world";
type ShoutyGreeting = Uppercase<Greeting>; // "HELLO, WORLD"型
type QuietGreeting = Lowercase<Greeting>; // "hello, world"型
type FirstLetter = Capitalize<"hello">; // "Hello"型
type RestOfWord = Uncapitalize<"Hello">; // "hello"型

// マップ型でのキーのリマッピング
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
};

interface Person {
  name: string;
  age: number;
}

type PersonGetters = Getters<Person>;
// {
//   getName: () => string;
//   getAge: () => number;
// }

// プロパティのフィルタリング
type RemoveKindField<T> = {
  [K in keyof T as Exclude<K, "kind">]: T[K]
};

// 再帰的な条件付き型
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

// 使用例
type A = Awaited<Promise<Promise<number>>>; // number型
```

## TypeScript 4.2

### 主な変更点

- **スマートな型エイリアスの保持 (Smarter Type Alias Preservation)**: 型エイリアスが使用された場合、その情報を保持するように改善されました。エラーメッセージ、.d.tsファイル出力、エディタでの型表示が改善され、複雑な型が読みやすく表示されるようになり、TypeScriptの使いやすさが向上しました。

- **タプル型での先頭/中間の残余要素 (Leading/Middle Rest Elements in Tuple Types)**: 残余要素（...rest）がタプル型の任意の位置に配置可能になりました。先頭に可変長の引数を持ち、後ろに固定の引数を持つ関数のモデル化が可能になりました。制約として、1つのタプルに1つの残余要素のみ許可され、残余要素の後にオプショナル要素は配置できません。

- **inオペレータに対する厳格なチェック (Stricter Checks For The in Operator)**: JavaScriptでは非オブジェクト型に対するinオペレータの使用は実行時エラーになりますが、TypeScript 4.2では設計時にこれをキャッチするように改善されました。

- **--noPropertyAccessFromIndexSignature**: インデックスシグネチャで宣言されたプロパティに対して、ドット記法（obj.prop）でのアクセスを制限するオプションが追加されました。明示的に宣言されていないプロパティへのアクセスをエラーとして検出可能になり、誤字などによるバグを早期に発見できるようになりました。

- **abstractコンストラクトシグネチャ (abstract Construct Signatures)**: コンストラクタシグネチャに`abstract`修飾子を指定可能になりました。抽象クラスを型パラメータとして渡せるようになり、ミックスインパターンなどで活用可能になりました。抽象クラスのインスタンス化を防ぎつつ、型安全に扱えるようになりました。

- **論理式での未呼び出し関数チェックの改善 (Improved Uncalled Function Checks in Logical Expressions)**: &&や||式内での未呼び出し関数のチェックが適用されるようになりました。strictNullChecksが有効な場合に、関数呼び出しを忘れるミスを検出できます。

- **分割代入変数の未使用マーク (Destructured Variables Can Be Explicitly Marked as Unused)**: 分割代入で取得した変数の先頭にアンダースコア（_）をつけることで未使用と明示可能になりました。noUnusedLocalsオプションが有効でも、_で始まる変数は未使用でもエラーになりません。

- **オプショナルプロパティと文字列インデックスシグネチャ間の緩和されたルール (Relaxed Rules Between Optional Properties and String Index Signatures)**: オプショナルプロパティを持つオブジェクト型が、互換性のある文字列インデックスシグネチャを持つ型に代入可能になりました。ただし、明示的にundefinedを含む型や、非オプショナルプロパティには適用されません。

### 新しい構文

```typescript
// タプル型での先頭/中間の残余要素
let foo: [...string[], number]; // 文字列の配列の後に数値が1つ
let bar: [boolean, ...string[], boolean]; // 真偽値、任意の数の文字列、真偽値

// abstractコンストラクトシグネチャ
interface HasArea {
  getArea(): number;
}

// abstract修飾子を使用したコンストラクタシグネチャ
let Ctor: abstract new () => HasArea = Shape;

// 分割代入変数の未使用マーク
const { _unused, ...rest } = obj; // _unusedは未使用と明示

// inオペレータに対する厳格なチェック
// エラーになるコード例
"foo" in 42; // エラー: 'number'型は'object'型に代入できません
```

## TypeScript 4.3

### 主な変更点

- **プロパティの読み書きに対する個別の型定義 (Separate Write Types on Properties)**: プロパティの読み取り時と書き込み時に異なる型を指定可能になりました。getterとsetterで異なる型を使用できるようになり、型変換APIのモデル化が改善されました。例えば、setterは文字列や真偽値を受け付けるが、getterは常に数値を返すといった実装が可能になりました。

- **override修飾子と--noImplicitOverrideフラグ**: メソッドがスーパークラスのメソッドをオーバーライドすることを明示的に示す`override`修飾子が追加されました。`--noImplicitOverride`フラグを使用すると、オーバーライドするメソッドに`override`修飾子の使用を強制できるようになりました。これにより、意図しないメソッドの上書きや、スーパークラスの変更による問題を早期に検出できます。

- **テンプレート文字列型の改善 (Template String Type Improvements)**: テンプレート文字列型の推論が改善され、文字列リテラル型によるコンテキスト型付けが可能になりました。異なるテンプレート文字列型間の関係性の検証と推論が強化され、複雑なテンプレート文字列パターンの型チェックが可能になりました。

- **ECMAScript #privateクラス要素の拡張**: `#private`名前を持つクラス要素がプロパティだけでなく、メソッドやアクセサにも適用可能になりました。staticメンバーにも`#private`名前を使用可能になり、実行時に真に非公開なクラスメンバーを定義する機能が拡張されました。

- **ConstructorParametersが抽象クラスで動作するように**: `ConstructorParameters`型ヘルパーが`abstract`クラスでも使用可能になりました。抽象クラスのコンストラクタパラメータ型を取得できるようになり、ファクトリパターンなどで活用可能になりました。

- **ジェネリクスのコンテキスト的な型の絞り込み (Contextual Narrowing for Generics)**: ジェネリック値に対する型の絞り込みロジックが改善されました。制約を持つジェネリック型のインスタンス検査が正しく動作するようになり、より複雑なジェネリックパターンでのコード記述が容易になりました。

- **常に真となるPromiseチェック (Always-Truthy Promise Checks)**: `strictNullChecks`が有効な場合、条件式で`Promise`オブジェクトを直接チェックするとエラーになるようになりました。これにより、`await`を忘れた可能性があるコードを検出し、バグを防止できます。

- **staticインデックスシグネチャ (static Index Signatures)**: クラスの静的側にインデックスシグネチャを宣言可能になりました。動的なプロパティアクセスをクラス自体に対して型安全に行えるようになりました。

### 新しい構文

```typescript
// プロパティの読み書きに対する個別の型定義
class Thing {
  #size = 0;
  
  // 読み取り時は常にnumber型
  get size(): number {
    return this.#size;
  }
  
  // 書き込み時はstring、number、boolean型を受け付ける
  set size(value: string | number | boolean) {
    let num = Number(value);
    
    // NaNなどの不正な値を防ぐ
    if (!Number.isFinite(num)) {
      this.#size = 0;
      return;
    }
    
    this.#size = num;
  }
}

// override修飾子の使用例
class Base {
  someHelperMethod() {
    // ...
  }
}

class Derived extends Base {
  // 明示的にオーバーライドを示す
  override someHelperMethod() {
    // ...
  }
}

// ECMAScript #privateクラス要素
class Foo {
  #someMethod() {
    //...
  }
  
  get #someValue() {
    return 100;
  }
  
  // クラス内からは#で始まるプライベートメンバーにアクセス可能
  publicMethod() {
    this.#someMethod();
    return this.#someValue;
  }
}

// staticインデックスシグネチャ
class ConfigFlags {
  static DEBUG = false;
  static PRODUCTION = false;
  
  // 静的インデックスシグネチャ
  static [key: string]: boolean;
}

// テンプレート文字列型の改善
type Color = "red" | "blue";
type Quantity = "one" | "two";
type SeussFish = `${Quantity} ${Color} fish`;
// SeussFish = "one red fish" | "one blue fish" | "two red fish" | "two blue fish"
```

## TypeScript 4.4

### 主な変更点

- **エイリアス条件と判別式の制御フロー分析 (Control Flow Analysis of Aliased Conditions and Discriminants)**: 型ガードの結果を定数に保存して再利用できるように改善されました。判別式を抽出して使用する場合でも元のオブジェクトの型を正しく絞り込み可能になり、複数の条件チェックを組み合わせた場合も型の絞り込みが正しく機能するようになりました。

- **シンボルとテンプレート文字列パターンのインデックスシグネチャ**: インデックスシグネチャで`symbol`型のキーがサポートされるようになりました。また、テンプレート文字列パターン（例：`` `data-${string}` ``）をインデックスシグネチャのキーとして使用可能になり、特定のプレフィックスを持つプロパティに対する型チェックが可能になりました。

- **catch句の変数に`unknown`型をデフォルトで使用 (--useUnknownInCatchVariables)**: `--useUnknownInCatchVariables`フラグが導入され、`strictNullChecks`が有効な場合、catch句の変数のデフォルト型が`any`から`unknown`に変更されました。これにより例外処理の型安全性が向上し、例外オブジェクトの使用前に型チェックが必要になりました。

- **正確なオプショナルプロパティ型 (--exactOptionalPropertyTypes)**: `--exactOptionalPropertyTypes`フラグが導入され、オプショナルプロパティ型が書かれた通りに解釈され、自動的に`| undefined`が追加されなくなりました。これによりプロパティの存在と`undefined`値の区別が可能になりました。

- **クラスの`static`ブロック**: クラスの静的メンバーの複雑な初期化コードを書くための`static`ブロックがサポートされるようになりました。静的ブロック内ではクラスのプライベートフィールドにアクセス可能で、複数の`static`ブロックを定義でき、記述順に実行されます。

- **パフォーマンスの改善**: 宣言ファイル出力の高速化、パス正規化の高速化、パスマッピングの高速化、`--strict`を使用した増分ビルドの高速化、大規模出力ファイルのソースマップ生成の高速化、`--force`ビルドの高速化など、多くのパフォーマンス改善が行われました。

- **JavaScriptのスペル提案**: JavaScriptファイルでもTypeScriptのスペル提案機能が利用可能になりました。`// @ts-check`や`checkJs`が無効でも「Did you mean…?」提案が表示されるようになりました。

- **インレイヒント**: パラメータ名や戻り値の型などの情報をコード内に表示する「インレイヒント」機能が追加されました。Visual Studio Codeなどのエディタと連携して、コード理解を助ける情報を表示します。

### 新しい構文

```typescript
// エイリアス条件と判別式の制御フロー分析
function example(x: string | number) {
  // 型ガードの結果を定数に保存
  const isString = typeof x === "string";
  
  // 保存した結果を使用しても型の絞り込みが機能
  if (isString) {
    console.log(x.toUpperCase()); // xはstring型として扱われる
  } else {
    console.log(x.toFixed(2)); // xはnumber型として扱われる
  }
}

// シンボルとテンプレート文字列パターンのインデックスシグネチャ
interface DataProps {
  // テンプレート文字列パターンをキーとして使用
  [key: `data-${string}`]: string;
}

const element: DataProps = {
  "data-id": "123",
  "data-user": "user001",
  // "id": "invalid" // エラー: 'id'は`data-${string}`パターンに一致しない
};

// クラスの静的ブロック
class MyClass {
  static x = 0;
  static y: number;
  
  // 複雑な初期化ロジックを静的ブロックで実装
  static {
    this.y = 1; // thisはクラス自体を参照
    
    // 複雑な初期化ロジック
    for (let i = 0; i < 10; i++) {
      this.x += i;
    }
  }
}

// catch句の変数に`unknown`型をデフォルトで使用
try {
  // 何らかの処理
} catch (e) {
  // TypeScript 4.4以降、eは`unknown`型
  // 使用前に型チェックが必要
  if (e instanceof Error) {
    console.log(e.message); // OK: eはError型
  }
}
```

## TypeScript 4.5

### 主な変更点

- **node_modulesからのlibサポート**: TypeScriptが組み込みの型定義ファイル（`.d.ts`）をオーバーライドする方法が導入されました。`@typescript/lib-*`パッケージを使用して特定の組み込みlibを置き換え可能になり、例えば`@typescript/lib-dom`を使用してDOMの型定義を特定のバージョンに固定できるようになりました。これにより型定義の更新を自分のペースで管理できるようになりました。

- **Awaited型とPromiseの改善**: 再帰的にPromiseをアンラップする`Awaited`ユーティリティ型が導入されました。`Promise.all`などの組み込み関数の型推論が改善され、非同期操作の型安全性が向上しました。

- **テンプレート文字列型を判別式として使用可能に**: テンプレート文字列型を使った型の絞り込みが可能になりました。テンプレート文字列パターンを判別式（discriminant）として使用できるようになり、文字列パターンに基づいた型の絞り込みが強化されました。

- **module es2022**: 新しいモジュール設定`es2022`が追加され、トップレベル`await`をサポート（`async`関数の外でも`await`が使用可能に）するようになりました。安定した最初のターゲットとして`es2022`が提供されました。

- **条件付き型の末尾再帰の最適化**: 条件付き型の末尾再帰を検出して最適化する機能が追加されました。これにより複雑な型の操作でも型の再帰的な展開の制限に達しにくくなり、文字列操作などの複雑な型定義が可能になりました。

- **インポートの削除を無効化 (Import Elision)**: `preserveValueImports`フラグが導入され、使用されていないように見えるインポートを保持する機能が追加されました。これによりSvelte、Vue.jsなどのフレームワークでの型安全なコード生成をサポートするようになりました。

- **インポート名に対する`type`修飾子**: 個々の名前付きインポートに`type`修飾子を使用可能になりました。同じモジュールから値と型を混在してインポートできるようになり、`import { someFunc, type BaseType } from "./some-module.js";`のような構文がサポートされるようになりました。

- **プライベートフィールドの存在チェック**: ECMAScriptの提案である「プライベートフィールドの存在チェック」がサポートされるようになりました。`in`演算子を使用してオブジェクトにプライベートフィールドが存在するか確認できるようになり、クラスインスタンスの「ブランドチェック」として活用できるようになりました。

- **インポートアサーション**: ECMAScriptの「インポートアサーション」提案がサポートされるようになりました。インポートされるファイルの形式を指定する構文が追加され、`import obj from "./something.json" assert { type: "json" };`のような構文がサポートされるようになりました。

### 新しい構文

```typescript
// Awaited型の使用例
type A = Awaited<Promise<string>>;  // string
type B = Awaited<Promise<Promise<number>>>;  // number
type C = Awaited<boolean | Promise<number>>;  // boolean | number

// インポート名に対するtype修飾子
// 値と型を同時にインポート
import { createUser, type User, type Admin } from "./user.js";

// プライベートフィールドの存在チェック
class HasX {
  #x: number = 0;
  
  static hasX(obj: any): obj is HasX {
    return #x in obj;  // プライベートフィールドの存在チェック
  }
}

// インポートアサーション
import data from "./data.json" assert { type: "json" };

// テンプレート文字列型を判別式として使用
type DataType = 
  | { type: `${string}Data`; payload: unknown }
  | { type: "error"; error: Error };

function processData(data: DataType) {
  if (data.type === "error") {
    // data.error が利用可能
    console.error(data.error.message);
  } else {
    // data.type は `${string}Data` 型
    // data.payload が利用可能
    console.log(`Processing ${data.type}:`, data.payload);
  }
}

// トップレベルawait (module es2022)
// ファイルの先頭レベルでawaitを使用可能
const response = await fetch("https://example.com/data");
const data = await response.json();
console.log(data);
```

## TypeScript 4.6

### 主な変更点

- **コンストラクタ内でsuper()呼び出し前のコードを許可**: 従来はクラスのプロパティ初期化子がある場合、コンストラクタ内でsuper()を呼び出す前に他のコードを実行できませんでした。TypeScript 4.6ではsuper()呼び出し前に他のコードを実行できるように緩和されました。ただしthisへの参照はsuper()呼び出し後にのみ許可される制約は維持されています。

- **分割代入された判別共用体の制御フロー分析**: オブジェクトから分割代入された変数に対する型の絞り込みが改善されました。判別プロパティ（discriminant property）を分割代入しても、他の分割代入された変数の型が正しく絞り込まれるようになりました。const宣言で分割代入された場合や、再代入されないパラメータの場合に有効です。

- **再帰的な型チェックの改善**: 複雑な再帰的型の互換性チェックが改善されました。明示的に書かれた深くネストされた型と、型チェック中に生成された無限に展開する型を区別できるようになりました。型チェックのパフォーマンスが向上し、一部のライブラリでは型チェック時間が50%削減されました。

- **インデックスアクセス型の推論改善**: マップされたオブジェクト型に対するインデックスアクセス型の推論が改善されました。複雑なジェネリック型でのインデックスアクセスの型推論がより正確になりました。

- **依存パラメータの制御フロー分析**: タプルの判別共用体を使用したレスト引数の型の絞り込みが改善されました。最初の引数の値に基づいて後続の引数の型を正しく絞り込めるようになりました。

- **--target es2022**: ES2022をターゲットとしてサポートするようになりました。クラスフィールドなどの機能を保持したまま出力可能になり、Array.at()、Object.hasOwn、Error作成時のcauseオプションなどの新しい組み込み機能を使用できるようになりました。

- **react-jsxモードでの不要な引数の削除**: `--jsx react-jsx`モードでのJSX変換時に不要な`void 0`引数が削除されるようになりました。これによりバンドルサイズの削減に貢献します。

- **JSDocの名前提案**: TypeScriptファイルでJSDocコメントのパラメータ名が実際の関数パラメータ名と一致しない場合に提案を表示するようになりました。コメントとコードの同期を維持するのに役立ちます。

- **JavaScriptファイルでの構文とバインディングエラーの拡張**: JavaScriptファイルでもTypeScriptの構文チェックが拡張されました。重複宣言や不正な修飾子の使用などのエラーを検出できるようになり、`// @ts-nocheck`コメントで無効化可能です。

### 新しい構文

```typescript
// コンストラクタ内でsuper()呼び出し前のコードを許可
class Base {
  constructor() {
    console.log("Base constructor");
  }
}

class Derived extends Base {
  prop = 10;
  
  constructor() {
    // TypeScript 4.6以前ではエラー、4.6以降では許可
    const initialization = "Initializing...";
    console.log(initialization);
    
    super();
    
    // super()呼び出し後にのみthisを参照可能
    console.log(this.prop);
  }
}

// 分割代入された判別共用体の制御フロー分析
type Action = 
  | { kind: "INCREMENT"; amount: number }
  | { kind: "DECREMENT"; amount: number }
  | { kind: "RESET" };

function reducer(state: number, action: Action) {
  // kindを分割代入
  const { kind } = action;
  
  if (kind === "INCREMENT") {
    // actionはINCREMENT型に絞り込まれる
    return state + action.amount;
  } else if (kind === "DECREMENT") {
    // actionはDECREMENT型に絞り込まれる
    return state - action.amount;
  } else {
    // actionはRESET型に絞り込まれる
    return 0;
  }
}
```

## TypeScript 4.7

### 主な変更点

- **ECMAScriptモジュールのNode.jsサポート**: Node.jsでのECMAScriptモジュール（ESM）サポートが追加されました。新しい`module`設定として`node16`と`nodenext`が追加され、`package.json`の`type`フィールドによるモジュール形式の制御をサポートします。また、`.mts`と`.cts`という新しいファイル拡張子をサポートし、CommonJSとESMの相互運用性が改善されました。`package.json`の`exports`、`imports`フィールドもサポートされるようになりました。

- **モジュール検出の制御**: `moduleDetection`オプションが追加され、ファイルがモジュールとして扱われるかどうかの制御が可能になりました。`"auto"`（デフォルト）、`"legacy"`（4.6以前の動作）、`"force"`（すべてのファイルをモジュールとして扱う）の3つの値を設定できます。

- **括弧付き要素アクセスの制御フロー分析**: リテラル型とユニークシンボルを使用したオブジェクトの要素アクセスに対する型の絞り込みが改善されました。シンボルをキーとして使用する場合の型ガードが正しく機能するようになりました。

- **オブジェクトとメソッドの関数推論の改善**: オブジェクトや配列内の関数に対するより細かな型推論が可能になりました。左から右への一貫した型の流れが実現しました。

- **インスタンス化式**: 関数やコンストラクタに直接型引数を渡すことが可能になりました。例えば、`const makeStringBox = makeBox<string>;`のように記述できます。汎用的な関数をより特化した関数として使用する際に便利です。

- **`infer`型変数での`extends`制約**: 条件付き型の`infer`キーワードで型変数に制約を追加できるようになりました。例えば、`T extends [infer S extends string, ...unknown[]]`のように記述できます。これによりネストされた条件付き型を簡略化できます。

- **型パラメータのオプション分散アノテーション**: 型パラメータに`in`、`out`、または両方を指定して分散を明示的に制御できるようになりました。`out T`（共変）、`in T`（反変）、`in out T`（不変）の指定が可能で、型チェックの精度と速度の向上に貢献します。

- **`moduleSuffixes`によるモジュール解決のカスタマイズ**: モジュール指定子の検索方法をカスタマイズするための`moduleSuffixes`オプションが追加されました。例えば、`"moduleSuffixes": [".ios", ".native", ""]`のように設定できます。React Nativeなどのプロジェクトで各ターゲットプラットフォーム向けに別々の設定が可能になりました。

- **resolution-mode**: `/// <reference types="..." resolution-mode="require" />`または`/// <reference types="..." resolution-mode="import" />`ディレクティブをサポートするようになりました。CommonJSモジュールからECMAScriptモジュールの型を参照する場合や、その逆の場合に便利です。

- **ソース定義へ移動**: 新しいエディタコマンド「ソース定義へ移動」（Go To Source Definition）が追加されました。宣言ファイル（.d.ts）ではなく、実装ファイル（.jsや.ts）の定義を検索します。

- **グループを考慮したインポートの整理**: 「インポートの整理」機能がインポート文のグループを維持するように改善されました。コメントや改行で区切られたインポートグループの順序が保持されます。

- **オブジェクトメソッドのスニペット補完**: オブジェクトリテラルのメソッド補完時に、名前だけでなくメソッド定義全体のスニペット補完を提供するようになりました。

### 新しい構文

```typescript
// ECMAScriptモジュールのNode.jsサポート
// package.json
{
  "name": "my-package",
  "type": "module",  // "module"または"commonjs"を指定
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  }
}

// .mts ファイル (ESM)
export function hello() {
  console.log("Hello from ESM");
}

// .cts ファイル (CommonJS)
export function hello() {
  console.log("Hello from CommonJS");
}

// インスタンス化式
function makeBox<T>(value: T) {
  return { value };
}

// 特定の型に特化した関数を作成
const makeStringBox = makeBox<string>;
const stringBox = makeStringBox("hello"); // { value: string }

// `infer`型変数での`extends`制約
type FirstString<T> = T extends [infer S extends string, ...unknown[]] ? S : never;

// 使用例
type T1 = FirstString<[string, number, boolean]>; // string
type T2 = FirstString<[123, number, boolean]>; // never (123は文字列ではない)

// 型パラメータのオプション分散アノテーション
// 共変（out）- 型パラメータが出力位置にのみ現れる
interface Getter<out T> {
  get(): T;
}

// 反変（in）- 型パラメータが入力位置にのみ現れる
interface Setter<in T> {
  set(value: T): void;
}

// 不変（in out）- 型パラメータが入力と出力の両方の位置に現れる
interface GetAndSet<in out T> {
  get(): T;
  set(value: T): void;
}
```

## TypeScript 4.8

### 主な変更点

- **交差型の簡略化、共用体型の互換性、型の絞り込みの改善**: `--strictNullChecks`モードでの型の正確性と一貫性が改善されました。`unknown`型が`{} | null | undefined`型と互換性を持つようになり、オブジェクト型と`{}`の交差型が単純化され、オブジェクト型に簡略化されるようになりました。`NonNullable<T>`型が`T & {}`として再定義され、条件付き型からより効率的な交差型になりました。型の絞り込みも改善され、`unknown`型が`{} | null | undefined`と同様に真偽値チェックで絞り込まれるようになりました。また、ジェネリック値の型の絞り込みが改善され、`null`や`undefined`チェック後に`{}`との交差型として扱われるようになりました。

- **テンプレート文字列型での`infer`型の推論改善**: テンプレート文字列型内で`extends`制約付きの`infer`型変数を使用する場合、リテラル型が抽出されるようになりました。例えば、`` "100" extends `${infer U extends number}` ? U : never ``が`number`ではなく`100`型になります。文字列からプリミティブ型への変換が可能な場合のみリテラル型として推論されます。

- **`--build`、`--watch`、`--incremental`のパフォーマンス改善**: ウォッチモードでの不要なタイムスタンプ更新を回避し、再ビルド速度が向上しました。大規模なコードベースで10〜25%の時間削減、変更がない場合は最大40%の時間削減が実現しました。

- **オブジェクトと配列リテラルの比較時のエラー**: オブジェクトや配列リテラルを`===`や`==`で直接比較する誤用を検出するようになりました。JavaScriptではオブジェクト同士の比較は参照比較であり、値比較ではないことを警告します。

- **バインディングパターンからの型推論の改善**: 分割代入パターンが型引数の候補として直接使用されなくなり、より正確な型推論が可能になりました。型引数の推論時にバインディングパターンは補助的なヒントとしてのみ使用されます。

- **ファイル監視の修正（特に`git checkout`時）**: Unix系システムでのファイル監視の問題が修正されました。iノードベースのファイルシステムでのファイル変更検出が改善され、vimでの保存やgitブランチ切り替え後の型チェックの問題が解決しました。

- **参照検索のパフォーマンス改善**: エディタでの「参照を検索」機能のパフォーマンスが約20%向上しました。

- **自動インポートから特定のファイルを除外**: エディタ設定で自動インポート候補から特定のファイルやパターンを除外できるようになりました。設定例：`"typescript.preferences.autoImportFileExcludePatterns": ["**/node_modules/@types/node"]`

- **制約のないジェネリック型が`{}`に代入できなくなる変更**: `strictNullChecks`有効時、制約のない型パラメータが`{}`や`object`型の位置で使用される場合にエラーになるようになりました。これは`null`や`undefined`が不正な値として渡される可能性を防止するためです。修正方法としては、型パラメータに`extends {}`制約を追加するか、実行時チェックを行うことが推奨されています。

- **JavaScriptファイルでの型のインポート/エクスポートの禁止**: JavaScriptファイルで値を持たない型だけをインポート/エクスポートするとエラーになるようになりました。これはECMAScriptモジュールでの実行時エラーを防止するための変更です。修正方法としては、`import`文で型を直接参照せず、`/** @typedef */`コメントを使用することが推奨されています。

### 新しい構文

```typescript
// 交差型の簡略化と型の絞り込みの改善
function f(x: unknown, y: {} | null | undefined) {
  // 以前はエラーだったが、TypeScript 4.8では動作する
  x = y; // unknownは{} | null | undefinedと互換性がある
  
  // 型の絞り込みの改善
  if (x) {
    // xは{}型に絞り込まれる
    const z: {} = x; // OK
  }
}

// NonNullable<T>の再定義
// 以前の定義
// type NonNullable<T> = T extends null | undefined ? never : T;

// 新しい定義
type NonNullable<T> = T & {};

// テンプレート文字列型での`infer`型の推論改善
type ExtractNumber<S> = S extends `${infer U extends number}` ? U : never;

// 使用例
type T1 = ExtractNumber<"100">; // 100 (numberリテラル型)
type T2 = ExtractNumber<"hello">; // never (数値に変換できない)

// 制約のないジェネリック型が`{}`に代入できなくなる変更
function beforeTS48<T>(value: T) {
  const obj: {} = value; // TypeScript 4.8ではエラー
}

// 修正方法1: 型パラメータに制約を追加
function afterTS48<T extends {}>(value: T) {
  const obj: {} = value; // OK
}

// 修正方法2: 実行時チェックを追加
function afterTS48Alternative<T>(value: T) {
  if (value !== null && value !== undefined) {
    const obj: {} = value; // OK
  }
}
```

## TypeScript 4.9

### 主な変更点

- **satisfiesオペレータ**: 式の型を検証しつつ、その式の具体的な型情報を保持するための新しい`satisfies`演算子が追加されました。型アノテーションとは異なり、式の具体的な型情報が失われません。オブジェクトのプロパティが特定の型を満たしているかを検証しつつ、各プロパティの具体的な型情報を保持できます。例えば、`const palette = { red: [255, 0, 0], green: "#00ff00" } satisfies Record<string, string | number[]>`のように使用できます。

- **inオペレータによる未リストプロパティの型絞り込み**: `in`演算子を使用した型の絞り込みが改善されました。型定義に明示的にリストされていないプロパティに対しても型の絞り込みが機能するようになりました。例えば、`unknown`型のオブジェクトに対して`"name" in obj`のチェックを行うと、`obj.name`にアクセス可能になります。型が`Record<"property-key", unknown>`と交差するように絞り込まれます。

- **クラスの自動アクセサ**: ECMAScriptの新機能「auto-accessors」をサポートするようになりました。`accessor`キーワードを使用してクラスのプロパティを宣言できるようになりました。内部的には`get`/`set`アクセサと到達不能なプライベートプロパティに変換されます。例えば、`class Person { accessor name: string; }`のように宣言できます。

- **NaNとの等価チェックに関する警告**: `NaN === value`や`NaN == value`などの比較が常に`false`を返すことを警告するようになりました。また、`NaN !== value`や`NaN != value`などの比較が常に`true`を返すことも警告します。代わりに`Number.isNaN(value)`を使用するよう提案されます。

- **ファイル監視がファイルシステムイベントを使用するように**: ファイル監視がポーリング方式からファイルシステムイベント方式にデフォルト変更されました。これによりCPUリソースの使用量が大幅に削減され、大規模なプロジェクトや`--watch`モードでのパフォーマンスが向上しました。ネットワークファイルシステムなど特殊な環境では従来のポーリング方式に戻すことも可能です。

- **「未使用のインポートを削除」と「インポートを並べ替え」コマンド**: エディタ向けに新しいコマンド「未使用のインポートを削除」が追加されました。既存の「インポートを整理」（削除と並べ替えを同時に行う）と「インポートを並べ替え」（並べ替えのみ）に加えて、削除のみを行うコマンドが利用可能になりました。Visual Studio Code 1.73以降でコマンドパレットから利用できます。

- **returnキーワードの定義へ移動**: エディタで`return`キーワードに対して「定義へ移動」を実行すると、対応する関数の先頭にジャンプするようになりました。これにより、どの関数に`return`が属しているかを素早く確認できるようになりました。

- **パフォーマンスの改善**: 構文ノードの走査関数`forEachChild`と`visitEachChild`がジャンプテーブルを使用するように最適化されました。これによりバインディングフェーズで最大20%、出力生成で最大3%の時間削減が実現しました。また、条件付き型の真の分岐での型情報保持方法が最適化され、型チェック時間が約3%削減されました。

### 新しい構文

```typescript
// satisfiesオペレータ
// 型アノテーションを使用した場合
const palette1: Record<string, string | number[]> = {
  red: [255, 0, 0],
  green: "#00ff00",
  blue: [0, 0, 255]
};
// palette1.redは(string | number[])型として扱われる
// palette1.red[0]はエラー: プロパティ '0' は型 'string | number[]' に存在しません。

// satisfiesオペレータを使用した場合
const palette2 = {
  red: [255, 0, 0],
  green: "#00ff00",
  blue: [0, 0, 255]
} satisfies Record<string, string | number[]>;
// palette2.redはnumber[]型として扱われる
// palette2.red[0]は有効: 255にアクセス可能

// inオペレータによる未リストプロパティの型絞り込み
function processValue(value: unknown) {
  if ("name" in value) {
    // TypeScript 4.9以降では、value.nameにアクセス可能
    console.log(value.name);
  }
}

// クラスの自動アクセサ
class Person {
  // 自動アクセサ
  accessor name: string;
  
  constructor(name: string) {
    this.name = name;
  }
}

// 内部的には以下のように変換される
class PersonInternal {
  #__name: string;
  
  get name() {
    return this.#__name;
  }
  
  set name(value: string) {
    this.#__name = value;
  }
  
  constructor(name: string) {
    this.name = name;
  }
}
```

## TypeScript 5.0

### 主な変更点

- **デコレータ**: ECMAScriptの新機能であるデコレータをサポートするようになりました。クラスやそのメンバーを再利用可能な方法でカスタマイズできます。メソッド、プロパティ、アクセサ、クラス自体に適用可能で、デコレータ関数は対象のメソッドや要素を受け取り、新しい関数や動作を返すことができます。コンテキストオブジェクトを通じてメタデータにアクセスでき、`addInitializer`を使用してコンストラクタの開始時にフックを追加することも可能です。これは以前の実験的デコレータ（`--experimentalDecorators`）とは異なる新しい実装です。

- **constタイプパラメータ**: ジェネリック型パラメータに`const`修飾子を追加できるようになりました。これにより、`as const`を使わなくても、リテラル型の推論が可能になります。例えば、`function getNamesExactly<const T extends HasNames>(arg: T): T["names"] { ... }`のように使用でき、配列やオブジェクトの具体的なリテラル型が保持されます。

- **複数の設定ファイルを`extends`でサポート**: `tsconfig.json`の`extends`フィールドが複数のエントリを取れるようになりました。例えば、`"extends": ["./tsconfig1.json", "./tsconfig2.json"]`のように指定できます。これは複数の設定ファイルから設定を継承する場合に便利で、競合するフィールドがある場合は後のエントリが優先されます。

- **すべての`enum`がユニオン`enum`に**: すべての列挙型がユニオン型として扱われるようになりました。計算された列挙型メンバーにも固有の型が作成され、列挙型の絞り込みやメンバーの型参照が全ての列挙型で可能になりました。

- **`--moduleResolution bundler`**: バンドラー向けの新しいモジュール解決戦略が追加されました。Vite、esbuild、swc、Webpack、Parcelなどのモダンバンドラーに適した設定で、ECMAScriptモジュールとCommonJSのルックアップルールを融合しています。拡張子なしのインポートをサポートしつつ、パッケージの`export`条件では`import`を優先します。

- **解決カスタマイズフラグ**: モジュール解決をカスタマイズするための新しいフラグが追加されました。`allowImportingTsExtensions`（TypeScript固有の拡張子でのインポートを許可）、`resolvePackageJsonExports`（`package.json`の`exports`フィールドを参照するように強制）、`resolvePackageJsonImports`（`package.json`の`imports`フィールドを参照するように強制）、`allowArbitraryExtensions`（任意の拡張子を持つファイルのインポートを許可）、`customConditions`（`exports`や`imports`フィールドの解決時に追加の条件を指定）などがあります。

- **`--verbatimModuleSyntax`**: インポート削除（import elision）の動作を簡素化するフラグが追加されました。`type`修飾子のないインポート/エクスポートはそのまま残し、`type`修飾子のあるものは完全に削除するという「見たままが得られる」シンプルなルールを採用しています。これは`--importsNotUsedAsValues`と`--preserveValueImports`の代替として導入されました。

- **`export type *`のサポート**: 型のみのエクスポートで`export * from "module"`や`export * as ns from "module"`構文をサポートするようになりました。例えば、`export type * as vehicles from "./vehicles"`のように使用できます。

- **JSDocでの`@satisfies`サポート**: TypeScript 4.9で導入された`satisfies`演算子をJSDocでも使用できるようになりました。式の型を検証しつつ、その式の具体的な型情報を保持できます。例えば、`/** @satisfies {ConfigSettings} */ let myConfigSettings = { ... }`のように使用できます。

- **JSDocでの`@overload`サポート**: 関数オーバーロードをJSDocで宣言できるようになりました。例えば、`/** @overload */ /** @param {string} value */ /** @return {void} */`のように使用できます。

- **`--build`モードでの出力固有フラグの受け渡し**: `--declaration`、`--emitDeclarationOnly`、`--declarationMap`、`--sourceMap`、`--inlineSourceMap`などのフラグを`--build`モードで使用できるようになりました。これにより、開発ビルドと本番ビルドで異なる設定を簡単に適用できます。

- **大文字小文字を区別しないインポートの並べ替え**: エディタでのインポート整理機能が大文字小文字を区別しない並べ替えをデフォルトでサポートするようになりました。これによりESLintなどの他のツールとの競合が減少します。

- **網羅的な`switch`/`case`補完**: リテラル型の値に対する`switch`文を書く際、未カバーの`case`を自動的に補完する機能が追加されました。

- **速度、メモリ、パッケージサイズの最適化**: TypeScript 4.9と比較して多くのパフォーマンス向上が実現しました。npmパッケージサイズが約41%削減（63.8MBから約37.4MB）され、名前空間からモジュールへの移行によるビルドツールの最適化、コンパイラ内部のオブジェクト型の均一化とデータ構造の最適化、文字列シリアル化のキャッシングなどが行われました。多くのコードベースで10〜20%の速度向上が期待できます。

### 新しい構文

```typescript
// デコレータ
class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  @loggedMethod
  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

// デコレータ関数の定義
function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) {
  const methodName = String(context.name);
  
  // 元のメソッドを置き換える新しい関数を返す
  function replacementMethod(this: any, ...args: any[]) {
    console.log(`LOG: Entering method '${methodName}'.`);
    const result = originalMethod.call(this, ...args);
    console.log(`LOG: Exiting method '${methodName}'.`);
    return result;
  }
  
  return replacementMethod;
}

// 複数のデコレータを同時に適用
@bound @loggedMethod
greet() {
  console.log(`Hello, my name is ${this.name}.`);
}

// constタイプパラメータ
// 従来の方法
function getFirstElement<T>(arr: T[]) {
  return arr[0];
}
// constなし: firstは string | number 型
const first = getFirstElement(["hello", 42]);

// constあり
function getFirstElementExact<const T>(arr: T[]) {
  return arr[0];
}
// constあり: firstExactは "hello" | 42 型（リテラル型）
const firstExact = getFirstElementExact(["hello", 42]);

// 配列の要素を正確に取得
function getNamesExactly<const T extends HasNames>(arg: T): T["names"] {
  return arg.names;
}
// namesは ["Alice", "Bob", "Charlie"] 型として推論される
const names = getNamesExactly({ names: ["Alice", "Bob", "Charlie"] });
```

## TypeScript 5.1

### 主な変更点

- **undefined を返す関数の暗黙的な return の簡素化**: 関数が明示的に `undefined` を返すと宣言されている場合、return 文がなくても良くなりました。以前は `void` 型や `any` 型を返す関数のみが return 文なしで許可されていましたが、TypeScript 5.1からは `undefined` を返す関数も return 文が不要になりました。これにより、`undefined` を返す関数を引数として期待する関数に、return 文のない関数を渡せるようになりました。また、`--noImplicitReturns` オプション使用時も、`undefined` を返す関数は全てのコードパスで明示的な return が不要になりました。

- **ゲッターとセッターの無関係な型**: `get` と `set` アクセサのペアで完全に無関係な型を指定できるようになりました。以前は `get` の型が `set` の型のサブタイプである必要がありましたが、明示的な型アノテーションがある場合に限り、完全に無関係な型が許可されるようになりました。例えば、DOM の `CSSStyleRule` の `style` プロパティは `CSSStyleDeclaration` として読み取られますが、書き込みは文字列のみ許可されるといった場合に便利です。

- **JSX 要素と JSX タグ型間の型チェックの分離**: JSX タグの型チェックが改善され、より柔軟な戻り値型をサポートするようになりました。新しい `JSX.ElementType` 型が導入され、JSX 要素のタグとして有効なものを正確に指定できるようになりました。これにより、`Promise` を返すコンポーネントなど、`JSX.Element` 以外を返すコンポーネントが使用可能になりました。

- **名前空間付き JSX 属性**: JSX で名前空間付き属性名（例：`a:b="hello"`）がサポートされるようになりました。名前空間付きタグ名は、最初のセグメントが小文字の名前の場合、`JSX.IntrinsicAttributes` で同様に検索されます。

- **typeRoots がモジュール解決で参照されるように**: TypeScript の指定されたモジュール検索戦略でパスを解決できない場合、指定された `typeRoots` に対して相対的にパッケージを解決するようになりました。

- **既存ファイルへの宣言の移動**: 新しいファイルだけでなく、既存のファイルへも宣言を移動できる機能がプレビュー版として追加されました。Visual Studio Code の最新バージョンで試用可能です。

- **JSX タグのリンクカーソル**: JSX タグ名に対するリンク編集（ミラーカーソル）がサポートされるようになりました。これはエディタが複数の場所を同時に自動的に編集できる機能で、TypeScript と JavaScript の両方のファイルで動作します。

- **@param JSDoc タグのスニペット補完**: TypeScript と JavaScript ファイルの両方で、`@param` タグを入力する際にスニペット補完が提供されるようになりました。これによりコードのドキュメント作成や JavaScript での JSDoc 型追加の手間が削減されます。

- **最適化**: 不要な型のインスタンス化を回避する最適化、ユニオンリテラルの否定的なケースチェックの最適化、JSDoc 解析のためのスキャナー呼び出しの削減など、パフォーマンスが大幅に向上しました。

- **破壊的変更**: TypeScript 5.1 は ECMAScript 2020 の機能を使用するため、Node.js 14.17 以降が最小ランタイム要件となりました。また、`typeRoots` オプションが指定されている場合、親ディレクトリの `node_modules/@types` フォルダの検索が行われなくなりました。

### 新しい構文

```typescript
// undefined を返す関数の暗黙的な return の簡素化
// TypeScript 5.1以前: エラー - 明示的な return 文が必要
function f4(): undefined {
  // no returns
  // エラー: A function whose declared type is neither 'void' nor 'any' must return a value.
}

// TypeScript 5.1: OK - return 文が不要
function f4(): undefined {
  // no returns
  // OK!
}

// ゲッターとセッターの無関係な型
class Example {
  // TypeScript 5.1以前: エラー - getter と setter の型が互換性がない
  get size(): number {
    return 42;
  }
  set size(value: string) {
    console.log(`Setting size to: ${value}`);
  }
}

// TypeScript 5.1: OK - 明示的な型アノテーションがある場合は無関係な型が許可される
class Example {
  // OK!
  get size(): number {
    return 42;
  }
  set size(value: string) {
    console.log(`Setting size to: ${value}`);
  }
}

// JSX 要素と JSX タグ型間の型チェックの分離
// Promise を返すコンポーネント
function AsyncComponent(): Promise<JSX.Element> {
  return Promise.resolve(<div>Hello, world!</div>);
}

// TypeScript 5.1以前: エラー - AsyncComponent は JSX.Element を直接返さない
// TypeScript 5.1: OK - JSX.ElementType として有効
const element = <AsyncComponent />;

// 名前空間付き JSX 属性
// TypeScript 5.1以前: エラー - 名前空間付き属性はサポートされていない
// TypeScript 5.1: OK
const element = <div xml:space="preserve">Preserved whitespace</div>;
```

## TypeScript 5.2

### 主な変更点

- **using宣言**: 明示的なリソース管理のためのusing宣言が導入されました
- **複合式でのawait**: 複合式内でのawaitがサポートされました
- **型のみのインポートパスでのTypeScript実装ファイル拡張子のサポート**: .tsファイル拡張子を含むインポートが可能になりました
- **カスタムJSXエレメントファクトリ**: JSXエレメントファクトリのカスタマイズが可能になりました

### 新しい構文

```typescript
// using宣言の例
{
  const getResource = () => {
    return {
      [Symbol.dispose]: () => {
        console.log("リソースを解放しました");
      }
    };
  };

  using resource = getResource(); // ブロックの終了時に自動的にリソースが解放される
  console.log("リソースを使用中...");
} // ここでresource.Symbol.dispose()が自動的に呼び出される

// 複合式でのawait
const result = await Promise.resolve(123) + await Promise.resolve(456);
console.log(result); // 579

// 型のみのインポートパスでのTypeScript実装ファイル拡張子のサポート
import type { User } from "./models.ts"; // TypeScript 5.2以前はエラー

// カスタムJSXエレメントファクトリ
/** @jsx h */
/** @jsxFrag Fragment */
import { h, Fragment } from 'preact';

const element = (
  <>
    <div>Hello</div>
  </>
);
```

## TypeScript 5.3

### 主な変更点

- **Import Attributes**: インポート文でアトリビュートを指定できるようになりました
- **switch (true)文の制御フロー分析の改善**: switch (true)文での型の絞り込みが改善されました
- **関数型の戻り値の互換性チェックの改善**: 関数型の戻り値の互換性チェックが改善されました
- **JSDocでの@satisfies タグのサポート**: JSDocで@satisfiesタグが使用可能になりました

### 新しい構文

```typescript
// Import Attributes
import json from "./data.json" with { type: "json" };

// switch (true)文の制御フロー分析の改善
function process(value: string | number) {
  switch (true) {
    case typeof value === "string":
      console.log(value.toUpperCase()); // valueはstring型として認識される
      break;
    case typeof value === "number":
      console.log(value.toFixed(2)); // valueはnumber型として認識される
      break;
  }
}

// JSDocでの@satisfiesタグのサポート
/**
 * @typedef {Object} Options
 * @property {string} name
 * @property {number} [age]
 */

/**
 * @satisfies {Options}
 */
const options = {
  name: "John",
  age: 30
};
```

## TypeScript 5.4

### 主な変更点

- **Closureを保持するthisパラメータ**: クラスメソッドのthisパラメータがクロージャを保持するようになりました
- **NoInfer型修飾子**: 型推論を防止するNoInfer型修飾子が導入されました
- **クラスのメンバーに対するsatisfies演算子**: クラスのメンバーに対してsatisfies演算子が使用可能になりました
- **オブジェクトメソッドのショートハンド記法の改善**: オブジェクトメソッドのショートハンド記法が改善されました

### 新しい構文

```typescript
// NoInfer型修飾子
type NoInfer<T> = [T][T extends any ? 0 : never];

function createUser<T>(name: T, age: NoInfer<T>) {
  return { name, age };
}

// Tはstring型に推論される
const user = createUser("John", "42"); // エラー: 'string' 型の引数を 'NoInfer<string>' 型のパラメーターに割り当てることはできません

// クラスのメンバーに対するsatisfies演算子
class Config {
  options = {
    timeout: 1000,
    retries: 3
  } satisfies { timeout: number, retries: number };
}
```

## TypeScript 5.5

### 主な変更点

- **Decorator Metadataのサポート**: デコレータメタデータがサポートされました
- **Enumerating Keysの改善**: オブジェクトのキー列挙が改善されました
- **Awaited型の改善**: Awaited型が改善され、より正確な型推論が可能になりました
- **新しいフラグ--moduleResolution bundler**: モジュール解決のためのbundlerフラグが追加されました

### 新しい構文

```typescript
// Decorator Metadataのサポート
function logged(target: any, context: ClassMethodDecoratorContext) {
  const methodName = String(context.name);
  return function(this: any, ...args: any[]) {
    console.log(`Calling ${methodName} with args:`, args);
    return target.apply(this, args);
  };
}

class Calculator {
  @logged
  add(a: number, b: number): number {
    return a + b;
  }
}

// Awaited型の改善
type Result = Awaited<Promise<Promise<string>>>; // string
```

## TypeScript 5.6

### 主な変更点

- **Nullishチェックとtruthyチェックの検出機能**: nullishチェックとtruthyチェックの検出が改善されました
- **イテレータヘルパーメソッド**: イテレータヘルパーメソッドがサポートされました
- **任意のモジュール識別子のサポート**: 任意の文字列をモジュール識別子として使用できるようになりました
- **新しいコンパイラオプション**: --noUncheckedSideEffectImportsと--noCheckオプションが追加されました

### 新しい構文

```typescript
// Nullishチェックとtruthyチェックの検出機能
function process(value: string | null | undefined) {
  // nullishチェック
  if (value != null) {
    console.log(value.toUpperCase()); // valueはstring型として認識される
  }

  // truthyチェック
  if (value) {
    console.log(value.toUpperCase()); // valueはstring型として認識される
  }
}

// イテレータヘルパーメソッド
const numbers = [1, 2, 3, 4, 5];
const iterator = numbers.values();

// map, filter, takeなどのメソッドが使用可能
const doubled = [...iterator.map(n => n * 2)]; // [2, 4, 6, 8, 10]

// 任意のモジュール識別子のサポート
// 出力: I have an 🍎 and a 🍌

// 数値や特殊文字を含む識別子も使用可能
export { someFunction as "function-1" };
export { otherFunction as "special!@#" };

import { "function-1" as func1 } from "./module";
import { "special!@#" as specialFunc } from "./module";
```

## TypeScript 5.7

### 主な変更点

- **非nullアサーション演算子の改善**: 非nullアサーション演算子の型チェックが改善されました
- **オブジェクトの分割代入の型推論の改善**: オブジェクトの分割代入の型推論が改善されました
- **新しいフラグ--verbatimModuleSyntax**: モジュール構文を保持するフラグが追加されました
- **JSDocでの@overrideタグのサポート**: JSDocで@overrideタグが使用可能になりました

### 新しい構文

```typescript
// 非nullアサーション演算子の改善
function process(value: string | null) {
  const length = value!.length; // TypeScript 5.7では、より厳密にチェックされる
}

// オブジェクトの分割代入の型推論の改善
function getUser() {
  return { name: "John", age: 30 };
}

const { name, ...rest } = getUser();
console.log(name); // string型
console.log(rest); // { age: number }型

// JSDocでの@overrideタグのサポート
class Base {
  method() {}
}

class Derived extends Base {
  /**
   * @override
   */
  method() {
    // ベースクラスのメソッドをオーバーライド
  }
}
```

## TypeScript 5.8

### 主な変更点

- **Exhaustivenessチェックの改善**: 網羅性チェックが改善されました
- **Tuple型の型推論の改善**: タプル型の型推論が改善されました
- **新しいフラグ--allowArbitraryExtensions**: 任意の拡張子を許可するフラグが追加されました
- **JSDocでの@parameterProperties タグのサポート**: JSDocで@parameterPropertiesタグが使用可能になりました

### 新しい構文

```typescript
// Exhaustivenessチェックの改善
type Status = "pending" | "fulfilled" | "rejected";

function handleStatus(status: Status) {
  switch (status) {
    case "pending":
      return "処理中...";
    case "fulfilled":
      return "完了";
    case "rejected":
      return "エラー";
    default:
      // TypeScript 5.8では、この行に到達することはないと判断される
      const _exhaustiveCheck: never = status;
      return _exhaustiveCheck;
  }
}

// Tuple型の型推論の改善
function tuple<T extends any[]>(...args: T): T {
  return args;
}

const t = tuple(1, "hello", true); // [number, string, boolean]型として正確に推論される

// JSDocでの@parameterProperties タグのサポート
/**
 * @class
 * @parameterProperties name
 */
function Person(name) {
  this.name = name;
}
```
